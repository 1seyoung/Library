---
link: https://www.acmicpc.net/problem/2309
algType:
  - 완전탐색
  - 정렬
---
# 일곱난쟁이

`브론즈1` | 브루트포스 알고리즘 | 정렬

일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.

아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.

## 입력

아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.

## 출력

일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.

## 결과 제출

```java
package week2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class day5 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        List<Integer> list = new ArrayList<>();
        int i =0;
        int sum =0;
        while(i<9){
            list.add(Integer.parseInt(br.readLine().trim()));
            sum+=list.get(i);
            i++;
        }

        //난쟁이 전체 키에서 가짜 두개 빼면서 가짜 인덱스 찾기
        int fake1 = -1, fake2 = -1;

        for (int j=0; j < 8; j++){
            for(int k=j+1; k < 9; k++){
                //만약 전체값에서 - fake1 -fake2 한 값이 100이면
                if((sum - list.get(j)-list.get(k)) == 100){
                    //가짜 인덱스 나옴
                    fake1 = j;
                    fake2 = k;
                    //나오면 종료
                    break;
                }

            }
        }

        //가짜난쟁이 사라지면서 인덱스 바뀔경우 고려
        if (fake1 > fake2) {
            list.remove(fake1);
            list.remove(fake2);
        } else {
            list.remove(fake2);
            list.remove(fake1);
        }
        //list.sort(null) -> java8 문법 -> 백준 x
        //정렬 직접 구현해보기
        Collections.sort(list);

        for (int height : list) {
            System.out.println(height);
        }

    }
}

```