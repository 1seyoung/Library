- 기업의 코딩테스트를 안정적으로 통과하려면 문제별 아이디어를 떠올리고 코드로 작성하기 까지 30분 이내(난이도 하 기준)
- 해결과정
	1. 지문 읽기 및 컴퓨터적 사고
	2. 요구사항(복잡도 분석)
	3. 문제 해결을 위한 아이디어 찾기
	4. 소스코드 설계 및 코딩

## 빠르게 한번에 읽기

![[파이썬 코테용 한 눈에]]

# Python
## Python 중요 포인트

- 시험 서버가 pypy 를 지원하면 이를 이용하는게 좋다

### 요구사항에 따라 적절한 알고리즘 설계하기

시간제한(수행 요구사항)을 확인해야함

시간 제한이 1초인 문제를 만났을 때, 일반적인 기준은 다음과 같다.

- **N의 범위가 500인 경우** : 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있음

- **N의 범위가 2000인 경우** : 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있음

- **N의 범위가 100,000인 경우** : O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있음

- **N의 범위가 10,000,000인 경우** : 시간복잡도가 O(N)인 알고리즘을 설계해야함

  

### Python 기본 연산자

- **나누기** /
- **나머지** %
- **몫** //
- **거듭제곱** **


#### 표준 입출력

```python
T = int(input())
sum_lst = []
for i in range(T):
    data = input()
    lst = list(map(int, data.split()))
```

#### 빠른 입출력 (sys 사용)

```python
import sys

T = int(sys.stdin.readline())
for i in range(T):
    data = sys.stdin.readline
    lst = list(map(int, data().split()))
```

#### 입력받아 딕셔너리 만들기

```python
num_users = int(input("생성할 사용자 수를 입력하세요: "))
users = []
for _ in range(num_users):
    name = input("사용자의 이름을 입력하세요: ")
    age = int(input("사용자의 나이를 입력하세요: "))
    users.append({"name": name, "age": age})
```

#### Lambda, Map, Reduce

##### Lambda 함수
```python
# 기본 형태
lambda 매개변수: 표현식

# 예시
# 람다 적용 전
def hap(x, y):
    return x + y
hap(10, 20)  # 30

# 람다 적용 후
(lambda x, y: x + y)(10, 20)  # 30
```

##### Map 함수
```python
# 기본 형태
map(함수, 리스트)

# 예시
map(lambda x: x**2, range(5))
```

##### Reduce 함수
```python
from functools import reduce

# 기본 형태
reduce(함수, 시퀀스, 초기값)

# 예시
# 누적값
reduce(lambda x, y: x + y, [0, 1, 2, 3, 4])

# 최대값
reduce(lambda a, b: a if (a > b) else b, [1, 100, 2])
```

#### defaultdict

```python
from collections import defaultdict

# 리스트를 기본값으로 사용
d = defaultdict(list)

# 정수(0)를 기본값으로 사용
d = defaultdict(int)

# 집합을 기본값으로 사용
d = defaultdict(set)

# 딕셔너리를 기본값으로 사용
d = defaultdict(dict)

# 실수(0.0)를 기본값으로 사용
d = defaultdict(float)
```

defaultdict는 요청한 키가 존재하지 않을 때, 자동으로 기본값을 생성하여 해당 키에 할당하는 딕셔너리입니다. 이를 사용하면 코드 실행 중에 키 에러를 방지할 수 있습니다.

#### 리스트 컴프리헨션의 활용
리스트 컴프리헨션은 간결한 구문을 통해 리스트의 초기화나 조작 시 유용함.

**[ ( 변수를 활용한 값 ) for ( 사용할 변수 이름 ) in ( 순회할 수 있는 값 )]**

리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용될 수 있음

##### NxM 크기의 리스트 초기화

`array = [[0]* m for _ in range(n) ]`

##### 리스트에서 특정 값을 가지는 원소를 모두 제거

`i for i in result if i not in remove_set`

#### 출력에서 시간 줄이기 sys.stdin.readline()
- input() 보다는 sys 라이브러리에서 제공하는 sys.stdin.readline()

```python
import sys
data = sys.stdin.readline()
```

##### N개의 정수를 한 줄로 입력 받는다면?

```Python
import sys
read = sys.stdin.readline
N, M, K = map(int, data().split())

```

##### N개의 정수를 한 줄로 입력 받아 List에 저장할 경우

```Python
import sys
data = sys.stdin.readline
data_list = list(map(int, read().split()))

```

##### 이차원 배열 그래프 입력받기

```Python
import sys
data = sys.stdin.readline
N = int(data())
matrix = [list(map(int, read().split())) for _ in range(N)]
```


## Python 코딩테스트 라이브러리

### 문자열 관련 함수

- `upper()` : 문자열의 모든 알파벳을 대문자로 변환
- `lower()` : 문자열의 모든 알파벳을 소문자로 변환
- `join()` : 문자열을 특정 구분자로 연결
- `strip()` : 문자열 양쪽 끝의 공백 또는 지정된 문자를 제거
- `rstrip()` : 문자열의 오른쪽 공백 또는 지정된 문자를 제거
- `lstrip()` : 문자열의 왼쪽 공백 또는 지정된 문자를 제거
- `replace()` : 문자열 내의 특정 문자열을 다른 문자열로 치환
- `split()` : 문자열을 특정 구분자로 나누어 리스트로 반환
- `find()` : 문자열 내에서 특정 문자의 첫 번째 인덱스를 반환 (찾지 못하면 -1)
- `count()` : 문자열 내에서 특정 문자의 등장 횟수를 반환

### 리스트 및 반복 가능한 객체 관련 함수

- `sum()` : 리스트나 튜플 등 반복 가능한 객체의 합을 반환
- `min()` : 반복 가능한 객체 중 최소값을 반환
- `max()` : 반복 가능한 객체 중 최대값을 반환
- `sort()` : 리스트의 요소들을 오름차순으로 정렬하며, `reverse=True` 옵션 사용 시 내림차순 정렬
- `sorted()` : 반복 가능한 객체를 정렬한 새로운 리스트를 반환
- `enumerate()` : 리스트 등의 반복 가능 객체를 인덱스와 함께 반환
- `len()` : 리스트, 문자열 등 반복 가능한 객체의 길이를 반환
- `map()` : 반복 가능한 객체의 모든 요소에 함수를 적용
- `filter()` : 조건에 맞는 요소만을 반환
- `zip()` : 여러 리스트의 요소들을 튜플로 묶어 반환

### 기타

- `ord()` : 문자(char)를 해당하는 유니코드 값(int)으로 변환
- `chr()` : 유니코드 값을 해당하는 문자(char)로 변환
- `eval()` : 문자열로 표현된 수식을 실제 수식으로 평가하여 결과를 반환
- `abs()` : 숫자의 절댓값을 반환
- `divmod()` : 두 숫자를 나눈 몫과 나머지를 튜플로 반환
- `round()` : 실수를 소수점 n자리까지 반올림
- `pow()` : 제곱을 계산 (ex. `pow(2, 3)` = 2^3)

### itertools 라이브러리
반복 가능한 객체 처리
순열, 조합, 그리고 효율적인 반복 처리를 위해 사용

- 모든 경우의 수를 고려해야할 때 어떤 라이브러리를 효과적으로 사용할 수 있을까? 
	- itertools 라이브러리

- 순열 : 서로 다른 N 개에서 서로 다른 R개를 선택하여 일렬로 나열
- 조합 : 서로 다른 N개에서 순서에 상관 없이 서로 다른 R개를 선택하는 것

```python
from itertools import product  
data = ['A', 'B', 'C'] # 데이터 준비  
result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기 (중복 허용)  
print(result)

```


```python
from itertools import combinations_with_replacement  
data = ['A', 'B', 'C'] # 데이터 준비  
result= list(combinations_with_replacement(data, 2)) # 2개를 뽑는 모든 조합 구하기 (중복 허용  
print(result)
```





| 함수                                          | 설명                                          | 사용 예시                                                               |
| ------------------------------------------- | ------------------------------------------- | ------------------------------------------------------------------- |
| `itertools.permutations()`                  | 순열을 생성합니다.                                  | `list(itertools.permutations([1, 2, 3], 2))` -> `[(1, 2), ... ]`    |
| `itertools.combinations()`                  | 조합을 생성합니다.                                  | `list(itertools.combinations([1, 2, 3], 2))` -> `[(1, 2), ... ]`    |
| `itertools.product()`                       | 데카르트 곱(cartesian product)을 구합니다.            | `list(itertools.product([1, 2], ['a', 'b']))` -> `[(1, 'a'), ... ]` |
| `itertools.combinations_with_replacement()` | 중복을 허용한 조합을 생성합니다.                          | `list(itertools.combinations_with_replacement([1, 2], 2))`          |
| `itertools.chain()`                         | 여러 iterable을 하나의 iterable처럼 이어붙여서 반환합니다.    | `list(itertools.chain([1, 2], [3, 4]))` -> `[1, 2, 3, 4]`           |
| `itertools.islice()`                        | iterable에서 일정 범위를 추출합니다.                    | `list(itertools.islice(range(10), 2, 7))` -> `[2, 3, 4, 5, 6]`      |
| `itertools.cycle()`                         | iterable을 무한히 반복합니다.                        | `cycle_iter = itertools.cycle([1, 2, 3])`                           |
| `itertools.accumulate()`                    | iterable의 누적 합계를 계산합니다.                     | `list(itertools.accumulate([1, 2, 3, 4]))` -> `[1, 3, 6, 10]`       |
| `itertools.groupby()`                       | iterable을 key 함수를 기준으로 그룹화합니다. (정렬된 데이터 필요) | `itertools.groupby(data, key=lambda x: x['name'])`                  |
### heapq 라이브러리
힙(Heap) 자료 구조를 제공하며, 일반적으로 [[Python PriorityQueue|우선순위 큐(Priority Queue)]] 구현에 사용됨.
  ```python
import heapq

# 우선순위 큐 초기화
priority_queue = []

# (우선순위, 값)의 형태로 요소를 삽입 (우선순위가 낮을수록 먼저 처리됨)
heapq.heappush(priority_queue, (2, "Task 2"))
heapq.heappush(priority_queue, (1, "Task 1"))
heapq.heappush(priority_queue, (3, "Task 3"))

# 우선순위에 따라 큐에서 요소를 하나씩 꺼냄
while priority_queue:
    priority = heapq.heappop(priority_queue)
    print(priority)  # (우선순위, 값) 출력
  ```
• heapq는 최소 힙(Min-Heap)을 기반으로 하므로, 가장 작은 값을 먼저 꺼내게 됩니다.
• (우선순위, 값) 튜플의 형태로 값을 삽입하며, 우선순위가 낮은 순서대로 값이 처리됩니다.
• heappop()을 호출하면 우선순위가 가장 낮은 항목이 큐에서 제거되고 반환됩니다.

**참고:**
우선순위 큐에서 우선순위를 숫자로 관리하는데, 더 낮은 숫자가 높은 우선순위로 취급됩니다.

| 함수                             | 설명                          | 사용 예시                                                |
| ------------------------------ | --------------------------- | ---------------------------------------------------- |
| `heapq.heappush(heap, item)`   | 힙에 아이템을 추가                  | `heapq.heappush(heap, 3)`                            |
| `heapq.heappop(heap)`          | 힙에서 가장 작은 요소를 제거하고 반환       | `heapq.heappop(heap)` -> 가장 작은 요소 제거 및 반환            |
| `heapq.heapify(x)`             | 리스트를 힙 구조로 변환               | `heapq.heapify([3, 2, 1])` -> `[1, 2, 3]`            |
| `heapq.nlargest(n, iterable)`  | iterable에서 가장 큰 n개의 요소를 반환  | `heapq.nlargest(3, [1, 2, 3, 4, 5])` -> `[5, 4, 3]`  |
| `heapq.nsmallest(n, iterable)` | iterable에서 가장 작은 n개의 요소를 반환 | `heapq.nsmallest(3, [1, 2, 3, 4, 5])` -> `[1, 2, 3]` |
|                                |                             |                                                      |
### bisect (이진탐색) 라이브러리
이진 탐색(binary search) 기능을 제공하며, 정렬된 리스트에서의 효율적인 삽입과 검색을 지원.
(이진 탐색 : 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법 / 시작점 , 끝점, 중간점을 이용해 탐색 범위를 설정함)

**숫자 삽입 위치 찾기**
정렬된 리스트가 주어질 때, 새로운 숫자를 삽입해야 하는 위치를 찾아라. 동일한 숫자가 리스트에 존재한다면, 왼쪽에 삽입하도록 한다.

```python
import bisect

# 정렬된 리스트
arr = [1, 3, 4, 7, 9]

# 삽입할 숫자
x = 4

# 삽입 위치 찾기 (왼쪽에 삽입)
position = bisect.bisect_left(arr, x)
print(position)  # 결과: 2
```

**문제 예시 3: 범위 내 숫자 개수 세기**

정렬된 리스트와 두 개의 숫자 L과 R이 주어졌을 때, L 이상 R 이하의 값이 몇 개 있는지 구하라.
```python
import bisect

# 정렬된 리스트
arr = [1, 2, 4, 4, 6, 7, 9]

# 범위
L = 4
R = 7

# L 이상인 첫 위치와 R 이하인 마지막 위치를 찾음
left = bisect.bisect_left(arr, L)
right = bisect.bisect_right(arr, R)

# 개수 계산
count = right - left
print(count)  # 결과: 4
```

| 함수                                  | 설명                                                                             | 사용 예시                                                |
|---------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------|
| `bisect.bisect_left(a, x)`            | 리스트 `a`에서 `x`가 삽입될 왼쪽 위치를 반환. 동일 값이 있을 경우 왼쪽에 삽입됨 | `bisect.bisect_left([1, 2, 4, 4, 5], 4)` -> `2`           |
| `bisect.bisect_right(a, x)`           | 리스트 `a`에서 `x`가 삽입될 오른쪽 위치를 반환. 동일 값이 있을 경우 오른쪽에 삽입됨 | `bisect.bisect_right([1, 2, 4, 4, 5], 4)` -> `4`          |
| `bisect.insort_left(a, x)`            | 리스트 `a`에 `x`를 정렬된 순서를 유지하면서 왼쪽에 삽입                        | `bisect.insort_left([1, 2, 4, 5], 3)` -> `[1, 2, 3, 4, 5]` |
| `bisect.insort_right(a, x)`           | 리스트 `a`에 `x`를 정렬된 순서를 유지하면서 오른쪽에 삽입                       | `bisect.insort_right([1, 2, 4, 5], 4)` -> `[1, 2, 4, 4, 5]` |
### Collection 라이브러리

**deque**는 양 끝에서의 삽입 및 삭제가 O(1)로 매우 빠르기 때문에 큐와 스택 문제에서 자주 사용
- deque는 **큐**와 **스택** 문제에서 자주 사용되며, 특히 **BFS** (너비 우선 탐색)와 같은 알고리즘에서 큐로 많이 활용됩니다. deque를 이용하면 빠르고 효율적으로 문제를 해결할 수 있습니다.

**1. 스택 구현 (후입선출, LIFO)**

```python
from collections import deque

stack = deque()

# 스택에 요소 추가
stack.append(1)
stack.append(2)
stack.append(3)

# 스택에서 요소 제거 (후입선출)
print(stack.pop())  # 결과: 3
print(stack.pop())  # 결과: 2
```

**2. 큐 구현 (선입선출, FIFO)**

```python

from collections import deque

queue = deque()

# 큐에 요소 추가
queue.append(1)
queue.append(2)
queue.append(3)

# 큐에서 요소 제거 (선입선출)
print(queue.popleft())  # 결과: 1
print(queue.popleft())  # 결과: 2
```

**3. 회전 큐 (슬라이딩 윈도우 등)**


```python
from collections import deque

dq = deque([1, 2, 3, 4, 5])
dq.rotate(2)  # 오른쪽으로 2칸 회전
print(dq)     # 결과: deque([4, 5, 1, 2, 3])

dq.rotate(-1) # 왼쪽으로 1칸 회전
print(dq)     # 결과: deque([5, 1, 2, 3, 4])
```

### `collections` 라이브러리 메서드 정리

| 자료구조              | 메서드                                 | 설명                                    | 사용 예시                                                 |
| ----------------- | ----------------------------------- | ------------------------------------- | ----------------------------------------------------- |
| **`deque`**       | `append(x)`                         | 우측 끝에 요소 추가                           | `d.append(4)` -> `deque([1, 2, 3, 4])`                |
|                   | `appendleft(x)`                     | 좌측 끝에 요소 추가                           | `d.appendleft(0)` -> `deque([0, 1, 2, 3])`            |
|                   | `pop()`                             | 우측 끝에서 요소 제거 및 반환                     | `d.pop()` -> `3`, `deque([1, 2])`                     |
|                   | `popleft()`                         | 좌측 끝에서 요소 제거 및 반환                     | `d.popleft()` -> `1`, `deque([2, 3])`                 |
|                   | `extend(iterable)`                  | 우측 끝에 iterable의 요소들을 추가               | `d.extend([4, 5])` -> `deque([1, 2, 3, 4, 5])`        |
|                   | `extendleft(iterable)`              | 좌측 끝에 iterable의 요소들을 추가 (반대로 추가됨)     | `d.extendleft([0, -1])` -> `deque([-1, 0, 1, 2, 3])`  |
|                   | `rotate(n)`                         | 덱의 요소들을 n번 회전 (양수는 우측, 음수는 좌측 회전)     | `d.rotate(2)` -> `deque([2, 3, 1])`                   |
|                   | `clear()`                           | 덱의 모든 요소 제거                           | `d.clear()` -> `deque([])`                            |
|                   | `count(x)`                          | 덱에서 요소 `x`의 개수 반환                     | `d.count(2)` -> `1`                                   |
| **`Counter`**     | `most_common(n)`                    | 가장 빈도가 높은 n개의 요소 반환                   | `c.most_common(2)` -> `[('a', 3), ('b', 2)]`          |
|                   | `elements()`                        | Counter의 각 요소를 요소의 빈도수만큼 반환           | `list(c.elements())` -> `['a', 'a', 'a', 'b', 'b']`   |
|                   | `subtract(iterable)`                | 주어진 iterable의 값들을 Counter에서 뺌         | `c.subtract([1, 2])` -> `Counter({1: 0, 2: 1, 3: 2})` |
|                   | `update(iterable)`                  | 주어진 iterable의 값들을 Counter에 추가         | `c.update([1, 2])` -> `Counter({1: 1, 2: 2, 3: 2})`   |
| **`defaultdict`** | `defaultdict(default_factory)`      | 기본값을 제공하는 딕셔너리                        | `d = defaultdict(int)` -> `d[1] == 0`                 |
| **`namedtuple`**  | `namedtuple(typename, field_names)` | 이름을 가진 필드로 구성된 튜플 생성                  | `Point = namedtuple('Point', ['x', 'y'])`             |
|                   | `.field`                            | 필드에 직접 접근                             | `p = Point(1, 2)` -> `p.x` -> `1`                     |
| **`OrderedDict`** | `move_to_end(key, last=True)`       | 특정 키를 끝으로 이동 (last=False일 경우 시작으로 이동) | `d.move_to_end('a')`                                  |
|                   | `popitem(last=True)`                | 마지막(또는 첫 번째) 키-값 쌍을 제거하고 반환           | `d.popitem()`                                         |

### Math 라이브러리
필수적인 수학적 기능을 제공
팩토리얼 제곱근 최대공약수 삼각함수 관련

| 함수                          | 설명                                                                 | 사용 예시                                  |
|-------------------------------|----------------------------------------------------------------------|--------------------------------------------|
| `math.factorial(x)`            | x의 팩토리얼을 계산                                                   | `math.factorial(5)` -> `120`               |
| `math.sqrt(x)`                 | x의 제곱근을 반환                                                    | `math.sqrt(16)` -> `4.0`                   |
| `math.gcd(a, b)`               | a와 b의 최대공약수를 반환                                             | `math.gcd(36, 60)` -> `12`                 |
| `math.lcm(a, b)`               | a와 b의 최소공배수를 반환 (Python 3.9+)                               | `math.lcm(4, 5)` -> `20`                   |
| `math.pow(x, y)`               | x의 y 제곱을 계산                                                    | `math.pow(2, 3)` -> `8.0`                  |
| `math.log(x, base)`            | x의 로그(base)를 계산. base가 없으면 자연 로그를 반환                  | `math.log(10, 10)` -> `1.0`                |
| `math.sin(x)`                  | x 라디안의 사인값을 반환                                             | `math.sin(math.pi / 2)` -> `1.0`           |
| `math.cos(x)`                  | x 라디안의 코사인값을 반환                                           | `math.cos(0)` -> `1.0`                     |
| `math.tan(x)`                  | x 라디안의 탄젠트값을 반환                                           | `math.tan(math.pi / 4)` -> `1.0`           |
| `math.ceil(x)`                 | x보다 크거나 같은 최소 정수를 반환                                   | `math.ceil(4.2)` -> `5`                    |
| `math.floor(x)`                | x보다 작거나 같은 최대 정수를 반환                                   | `math.floor(4.9)` -> `4`                   |
| `math.fabs(x)`                 | x의 절댓값을 반환 (내장 함수 `abs()`와 비슷하지만, 항상 실수를 반환)  | `math.fabs(-3.5)` -> `3.5`                 |
| `math.pi`                      | 원주율 π의 값을 반환                                                 | `math.pi` -> `3.141592653589793`           |
| `math.e`                       | 자연상수 e의 값을 반환                                               | `math.e` -> `2.718281828459045`            |

### Datetime
- [*] datetime 라이브러리는 **날짜와 시간**을 다루는 데 사용되는 Python의 표준 라이브러리로, **날짜(date)**, **시간(time)**, **날짜와 시간(datetime)**, **시간 간격(timedelta)** 등 여러 개의 클래스로 구성되어 있습니다. 각각의 클래스가 특정한 용도를 가지고 있으며, 날짜와 시간을 쉽게 처리할 수 있도록 다양한 메서드를 제공합니다.

### `datetime` 라이브러리 주요 클래스 및 메서드 정리

| 클래스             | 메서드                          | 설명                                                                 | 사용 예시                                                |
|--------------------|---------------------------------|----------------------------------------------------------------------|----------------------------------------------------------|
| **`datetime.date`**    | `today()`                        | 현재 날짜 반환                                                        | `date.today()` -> `2024-09-27`                           |
|                    | `fromisoformat(date_string)`    | ISO 형식의 날짜 문자열을 `date` 객체로 변환                            | `date.fromisoformat('2024-09-27')`                       |
|                    | `strftime(format)`              | 날짜를 지정된 형식의 문자열로 변환                                     | `today.strftime('%Y-%m-%d')` -> `'2024-09-27'`           |
|                    | `replace(year, month, day)`     | 날짜의 특정 필드를 변경                                               | `today.replace(year=2023)`                               |
| **`datetime.time`**    | `strftime(format)`              | 시간을 지정된 형식의 문자열로 변환                                     | `time(12, 30, 45).strftime('%H:%M')` -> `'12:30'`        |
|                    | `replace(hour, minute)`         | 시간의 특정 필드를 변경                                               | `t.replace(minute=0)` -> `12:00:45`                      |
| **`datetime.datetime`** | `now()`                         | 현재 날짜와 시간 반환                                                  | `datetime.now()` -> `2024-09-27 17:45:30`                |
|                    | `combine(date, time)`           | `date` 객체와 `time` 객체를 합쳐 `datetime` 객체 생성                  | `datetime.combine(date.today(), time(12, 30))`           |
|                    | `strftime(format)`              | 날짜와 시간을 형식화된 문자열로 변환                                   | `now.strftime('%Y-%m-%d %H:%M:%S')` -> `'2024-09-27 17:45:30'` |
|                    | `strptime(date_string, format)` | 형식화된 문자열을 `datetime` 객체로 변환                               | `datetime.strptime('2024-09-27 17:45:30', '%Y-%m-%d %H:%M:%S')` |
| **`datetime.timedelta`** | `total_seconds()`              | 시간 간격을 초 단위로 반환                                             | `delta.total_seconds()`                                   |
|                    | `+ 연산자`                      | `timedelta`를 날짜나 시간에 더함                                       | `datetime.now() + timedelta(days=5)`                      |
| **`datetime.tzinfo`**    | `timezone.utc`                 | UTC 시간대를 반환                                                      | `datetime.now(timezone.utc)` -> `2024-09-27 08:45:30+00:00` |
| **형식 변환**         | `strftime(format)`              | 날짜와 시간을 문자열로 변환                                            | `now.strftime('%Y-%m-%d')` -> `'2024-09-27'`             |
|                    | `strptime(date_string, format)` | 문자열을 `datetime` 객체로 변환                                        | `datetime.strptime('2024-09-27', '%Y-%m-%d')`            |

**yyyymmdd 유효성 검사 with `datetime.strptime()`**


```python
from datetime import datetime

def validate_yyyymmdd(date_str):
    try:
        # 'YYYYMMDD' 형식의 문자열을 날짜 객체로 변환
        valid_date = datetime.strptime(date_str, '%Y%m%d')
        return True  # 변환 성공 시 유효한 날짜임
    except ValueError:
        return False  # 변환 실패 시 유효하지 않은 날짜임

# 유효성 검사 예시
print(validate_yyyymmdd('20240927'))  # True (유효한 날짜)
print(validate_yyyymmdd('20240230'))  # False (존재하지 않는 날짜)
print(validate_yyyymmdd('20241301'))  # False (잘못된 월)
```


# 알고리즘 및 자료구조
## 그리디 유형

“현재 상황에서 지금 당장 좋은 것만 고르는 방법”

>현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 x
>암기가 없어도 풀 수 있음
>다양한 유형의 문제// 정렬과 짝을 이뤄 출제

그리디 알고리즘은 최적의 해를 구하는 데 적합하지 않을 수 있음. 하지만 탐욕적으로 문제를 해결했을 때 정확한 해를 찾을 수 있다는 보장이 있을 경우, 매우 효과적이고 직관적인 방법임.

**고려해야 할 점**
• 고안한 아이디어의 정당성 확인이 중요함.

• 예시: 동전 문제에서 큰 단위의 동전이 작은 단위의 배수일 때, 작은 단위 동전을 조합해 더 나은 해를 만들 수 없으므로 탐욕적 접근이 유효함.

대부분의 그리디 알고리즘 문제에서는 최소한의 아이디어를 도출하고, 그 아이디어의 정당성 검토가 필요함.
## 구현 유형

풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제

완전 탐색과 시뮬레이션 유형을 모두 구현 유형으로 묶어서 생각하기

완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법

시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야하는 문제

두 개 모두 구현이 핵심

파이썬으로 하면 쉬운편

### 구현의 대표적인 문제 유형: 상하좌우, 시각

#### 시뮬레이션: 상하좌우

• 일련의 명령에 따라 개체를 차례대로 이동시키는 문제로, 시뮬레이션 유형에 속하며 **구현**의 중요한 대표적인 문제 유형임.

• **행렬**(이차원 배열)의 개념을 알아야 하며, dx, dy 리스트로 이동 방향을 설정하는 것이 효과적임.

• **응용 문제**: 게임 개발 등에서 활용 가능.

• 방향을 설정해 이동하는 문제에서는 dx, dy 리스트를 별도로 만들어 방향을 정하는 방식이 효율적임.

• **리스트 컴프리헨션** 문법을 사용해 2차원 리스트를 초기화하는 방법도 유용함.

>   **코드 예시**
> 
> 이 문제는 2차원 좌표계에서 주어진 명령에 따라 상하좌우로 이동하는 상황을 구현하는 문제입니다. dx, dy 리스트를 사용하여 이동 방향을 설정합니다.
> 
> **상하좌우** 문제에서 dx, dy 리스트를 사용하여 상, 하, 좌, 우로의 이동을 간단하게 처리합니다.

```Python
# N x N 크기의 공간에서 시작 위치
n = 5
x, y = 1, 1

# 이동 방향 (L, R, U, D)
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# 이동 계획
plans = ['R', 'R', 'U', 'L', 'D']

# 이동 실행
for plan in plans:
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
    
    # 공간을 벗어나지 않으면 이동
    if 1 <= nx <= n and 1 <= ny <= n:
        x, y = nx, ny

print(x, y)  # 최종 좌표 출력
```

#### 완전탐색: 시각

- 조건에 따라 모든 시간을 하나씩 검토하는 **완전탐색** 유형의 문제.
- 가능한 경우의 수를 모두 탐색하는 방식으로, 일반적으로 **비효율적인 시간 복잡도**를 가짐.
- **데이터의 수가 적을 때** 효과적이며, 이러한 상황에서 완전탐색을 고려할 수 있음.

> **코드 예시**
> 이 문제는 00시 00분 00초부터 N시 59분 59초까지의 모든 시간을 탐색하며, ‘3’이 하나라도 포함되는 경우를 카운트하는 문제입니다.
> 
> **시각** 문제에서는 모든 시간을 완전탐색하여 ‘3’이 포함된 경우를 카운트합니다.


```python
# N시까지 모든 시간을 탐색
n = 5

count = 0
for h in range(n + 1):
    for m in range(60):
        for s in range(60):
            # 시각에 '3'이 포함되어 있는지 확인
            if '3' in str(h) + str(m) + str(s):
                count += 1

print(count)  # '3'이 포함된 시간의 개수 출력
```


## DFS/BFS(깊이 우선탐색/너비우선탐색)

**요약**

|            | DFS                               | BFS                                 |
|------------|-----------------------------------|-------------------------------------|
| **차이**      | 깊이 우선 탐색                          | 너비 우선 탐색                           |
|            | 멀리 있는 노드를 우선으로 탐색                   | 가까운 노드를 우선으로 탐색                      |
| **동작원리**   | 스택                                | 큐                                   |
| **구현**      | 재귀함수 사용 또는 명시적 스택 사용               | 큐 자료구조 사용                         |
| **공통점**     | O(N)                               | O(N)                                |
| **알아둘 점**  | 그리디스트에서는 DFS 보다 BFS 구현이 더 바람직함       |                                     |
| **사용 시나리오** | - 모든 가능한 경우의 수를 탐색해야 할 때        | - 최단 경로를 찾아야 할 때                |
|                | - 복잡한 구조를 갖는 그래프에서 특정 경로나 패턴을 찾을 때  | - 같은 거리에 있는 노드들을 순차적으로 탐색해야 할 때  |
| **문제 힌트**  | - 미로 찾기에서 탈출 경로를 찾는 문제          | - 사회 네트워크 분석에서 특정 인물로부터의 최단 연결 경로 찾기 |
|                | - 결정 문제(예/아니오)를 해결할 때                | - 게임 맵 최단거리 구하기                 |
- **DFS**는 모든 가능한 경우의 수를 탐색할 때 주로 사용되며, 복잡한 구조에서 특정 경로나 패턴을 찾는 데 유용합니다. 예를 들어, 미로 찾기에서 미로의 특정 구역으로부터 탈출하는 가장 직접적인 경로를 찾는 문제에 적합합니다.

- **BFS**는 그래프에서 최단 경로를 찾는 문제에 적합하며, 같은 거리에 있는 노드들을 순차적으로 탐색하는 경우에 유용합니다. 예를 들어, 소셜 네트워크에서 한 사용자로부터 다른 사용자까지의 최단 연결 경로를 찾는 문제나, 게임 맵에서 최단 거리를 계산하는 문제에 적합합니다.

---
그래프를 탐색하기 위한 대표적인 두 가지 알고리즘

탐색 : 많은 양의 데이터 중 원하는 데이터를 찾는 과정

모든 리스트 (노드의 개수 +1) 크기로 할당 : 노드의 번호를 인덱스로 하여 바로 리스트에 접근할 수 있도록

스택/큐/재귀 개념 필요

> **[스택]**
> 
> 박스 쌓기
> 선입후출
> First in Last out
> 
> 파이썬에서 스택을 이용할 때는 별도의 라이브러리를 사용할 필요가 없음 (or deque)
> 
> append() , pop() 으로 가능
> 
>   
> [큐]
> 
> 대기줄
> 선입선출
> First in First out
> 
> 큐를 구현할 때는 collections 모듈에서 deque 자료구조를 이용
> deque 자료형 list로 바꾸는법 : list(queue)
> 
> [재귀]
> Recursive Function
> 자기자신을 다시 호출하는 함수
> 종료조건을 무조건 써야함
> 
> 재귀를 사용하면 코드가 간결해지는 이유 : 수학의 점화식을 소스코드로 옮겨서
>
> 수학 점화식 : 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것을 의미

### DFS : **Depth-First Search (깊이 우선 탐색)**

그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘은 **깊이 우선 탐색(DFS)**으로, **최대한 멀리 있는 노드를 우선 탐색**하는 방식임.

**그래프의 구조**
• 그래프는 **노드**와 **간선**으로 이루어짐
• 노드는 데이터, 간선은 노드 간의 연결을 의미함.

#### 그래프 표현 방법
1. **인접 행렬**: 2차원 배열을 사용해 그래프의 연결 관계를 표현하는 방식.
2. **인접 리스트**: 리스트를 사용해 그래프의 연결 관계를 표현하는 방식.

각 표현 방법은 문제 상황에 따라 적합하게 선택하여 사용함.

![[스크린샷 2024-09-27 오후 5.58.49.png]]
[인접행렬 방식]

**인접 행렬**은 2차원 배열을 사용해 각 노드가 연결된 형태를 기록하는 방식입니다. 노드 간의 연결이 없을 경우 **무한 비용**으로 작성하여 연결이 없는 것을 표현합니다. 일반적으로 큰 값으로 초기화하여 무한 비용을 나타냅니다. (예: 999999999)

**인접 행렬 예시**

아래는 노드 3개가 있는 그래프를 인접 행렬 방식으로 표현한 예시입니다.
![[스크린샷 2024-09-27 오후 5.59.03.png]]
**설명**
- 노드 0에서 1로 가는 비용은 7.
- 노드 1에서 2로는 연결이 없기 때문에 **무한 비용**으로 표시됨.
- 노드 0에서 2로 가는 비용은 5.

```python
INF = 999999999  # 무한을 의미하는 값으로 큰 수 설정

# 2차원 배열을 이용한 인접 행렬 방식의 그래프 표현
graph = [
    [0, 7, 5],        # 노드 0과 연결된 노드들
    [7, 0, INF],      # 노드 1과 연결된 노드들
    [5, INF, 0]       # 노드 2와 연결된 노드들
]

# 그래프 출력
for row in graph:
    print(row)
```



[인접 리스트 방식]
![[스크린샷 2024-09-27 오후 6.00.51.png]]

**인접 리스트**는 각 노드의 인접 노드 정보를 차례대로 연결하여 저장하는 방식임. **연결 리스트** 자료구조를 이용하지만, 파이썬에서는 리스트를 사용하여 간단히 구현할 수 있음. append() 메서드를 사용해 노드의 연결 정보를 저장함.

**인접 리스트 예시**

```python
# 각 노드의 연결 정보를 담은 리스트
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드들
graph[0].append((1, 7))  # 노드 0 -> 노드 1 (비용 7)
graph[0].append((2, 5))  # 노드 0 -> 노드 2 (비용 5)

# 노드 1에 연결된 노드들
graph[1].append((0, 7))  # 노드 1 -> 노드 0 (비용 7)

# 노드 2에 연결된 노드들
graph[2].append((0, 5))  # 노드 2 -> 노드 0 (비용 5)

# 결과: [[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
print(graph)
```

인접 리스트 방식은 **노드가 많고 간선이 적은** 희소 그래프에서 **효율적**임.

#### DFS (깊이 우선 탐색) 상세 설명

DFS는 **스택 자료구조**를 이용하여 그래프를 탐색함. **구체적인 동작 과정**은 다음과 같음:


1. **탐색 시작 노드를 스택에 삽입**하고, 방문 처리.
2. 스택의 **최상단 노드**에서 **방문하지 않은 인접 노드**가 있으면 그 인접 노드를 스택에 삽입하고 방문 처리. 방문하지 않은 인접 노드가 없으면 **스택에서 최상단 노드 제거**.
3. 2번 과정을 **반복**.

  
**방문 처리**
- 방문한 노드를 **스택에 삽입**하면서 처리된 노드가 **다시 삽입되지 않도록 체크**함.

**구현 관례**
- DFS는 일반적으로 **순서에 상관없이 처리**하지만, 코딩 테스트에서는 **노드 번호가 낮은 순서부터 처리**하는 경우가 많음.
- 따라서 관행적으로 번호가 낮은 순서부터 처리하는 방식으로 구현하는 것이 좋음.


#### DFS 알고리즘 기본 예시


```python
def dfs(graph, start, visited):
    # 스택 초기화
    stack = [start]
    visited[start] = True
    
    # 스택이 빌 때까지 반복
    while stack:
        v = stack.pop()
        print(v, end=' ')  # 노드 출력
        
        # 인접 노드를 방문 처리 (낮은 번호부터 처리)
        for i in graph[v]:
            if not visited[i]:
                stack.append(i)
                visited[i] = True

# 그래프 인접 리스트 (노드 0, 1, 2)
graph = [[1, 2], [0], [0]]

# 방문 처리 리스트 초기화
visited = [False] * len(graph)

# DFS 호출 (시작 노드 0)
dfs(graph, 0, visited)
```



## 정렬 알고리즘 

데이터를 특정한 기준에 따라서 순서대로 나열

정렬하면 이진탐색 가능(뒤에 나옴)(= 이진탐색의 전처리과정)

### 정렬 알고리즘

#### 선택정렬 (Selection Sort)
- 각 순회에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 위치를 교환.
- 간단하지만, 데이터 양이 많을 때 비효율적임.

#### 삽입정렬 (Insertion Sort)
- 각 순회에서 데이터를 적절한 위치에 삽입하여 정렬.
- 데이터가 거의 정렬되어 있을 때 매우 효율적임.

#### 퀵 정렬 (Quick Sort)
- 피벗을 기준으로 데이터를 분할하여 정렬하는 분할 정복 알고리즘.
- 평균적으로 매우 빠르지만, 최악의 경우 O(N^2)의 시간 복잡도를 가짐.

#### 계수정렬 (Counting Sort)
- 데이터의 크기에 따라 각 요소의 등장 횟수를 세어 정렬.
- 데이터의 크기 범위가 작을 때 매우 빠르고 효율적임.

### Python의 정렬 함수

#### 사용 예시
- `sorted(iterable, key=lambda x: x[1])`: 튜플의 두 번째 요소를 기준으로 정렬.
- `list.sort(reverse=True)`: 리스트를 내림차순으로 정렬.

### 코딩 테스트에서 정렬 알고리즘이 사용되는 경우
1. **정렬 라이브러리로 풀 수 있는 문제**
   - 문제에 복잡한 조건 없이 데이터를 정렬만 하면 되는 경우.
2. **정렬 알고리즘의 원리에 대해 묻는 문제**
   - 특정 정렬 알고리즘의 구현을 요구하거나, 특정 조건 하에서 정렬의 최적화를 묻는 문제.
3. **더 빠른 정렬이 필요한 문제**
   - 매우 큰 데이터셋이나 특수한 조건 하에서의 최적화가 필요한 경우.

### 추가 팁
- 정렬 알고리즘 선택 시 데이터의 특성과 문제 조건을 고려하면 더 효과적인 결과를 얻을 수 있음.
- 코딩 테스트에서는 대부분의 경우 Python의 내장 정렬 함수(`sorted`, `sort`)를 사용하여 시간을 절약할 수 있음.
- 복잡한 조건의 정렬은 키 함수(`key`)를 사용하여 쉽게 구현할 수 있음.
## 이진 탐색 (+ 탐색들)


### 순차탐색
- 리스트 내에서 특정 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인하는 방법.
- 데이터를 무조건 찾을 수 있는 방법.
- 최악의 경우 시간 복잡도: O(N).

### 이진탐색
- 배열이 정렬되어 있어야 사용 가능한 탐색 방법.
- 사용하는 변수: 시작점, 끝점, 중간점.
- 찾으려는 데이터와 중간점 위치의 데이터를 반복적으로 비교.
- 시간 복잡도: O(logN).

#### 구현 방법
1. 재귀함수
2. 단순 반복문

#### 추가 정보
- 탐색 범위가 큰 경우 이진 탐색으로 접근하는 것이 효율적.
- 이진 탐색 관련 알고리즘을 외우는 것이 일반적이지 않으나, 자주 사용되므로 외우는 것이 추천됨.
- 파라메트릭 서치 유형: 최적화 문제를 결정 문제로 바꾸어 해결하는 기법. 원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제에서 사용. 반복문 사용을 추천.

### 파이썬 이진 탐색 구현 코드

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        guess = arr[mid]

        if guess == target:
            return mid  # 타겟의 인덱스 반환
        if guess > target:
            high = mid - 1
        else:
            low = mid + 1

    return None  # 타겟이 리스트에 없는 경우 None 반환

# 예시 배열 (정렬되어 있어야 함)
arr = [1, 3, 5, 7, 9]

# 탐색 실행
print(binary_search(arr, 3))  # 출력: 1
print(binary_search(arr, -1)) # 출력: None
```

## 트리 자료구조

![[스크린샷 2024-09-28 오후 9.59.10.png]]


### 노드(Node)
- **노드**는 정보의 단위로서 어떠한 정보를 가지고 있는 개체로 이해할 수 있음.
- 트리는 그래프 자료구조의 일종으로, **파일 시스템**이나 **데이터베이스 시스템**과 같은 대규모 데이터 관리에 사용됨.

### 트리의 특징
- **부모 노드**와 **자식 노드**의 관계로 표현됨.
- **최상단 노드**는 **루트 노드**, **최하단 노드**는 **단말 노드**라고 함.
- 트리의 일부분도 또 다른 트리 구조를 형성하므로 이를 **서브트리**라고 부름.
- 트리는 **계층적 구조**를 가지며, 데이터를 정렬된 상태로 다루는 데 적합함.

---

## 이진 탐색 트리 (Binary Search Tree, BST)
![[스크린샷 2024-09-29 오전 3.06.33.png]]
- **이진 탐색이 가능하도록** 설계된 자료구조로, 모든 트리가 이진 탐색 트리는 아님.
- **특징**:
  - **왼쪽 자식 노드** < **부모 노드** < **오른쪽 자식 노드**
  - 즉, **왼쪽** 서브트리의 노드 값은 항상 **부모 노드**보다 작고, **오른쪽** 서브트리의 노드 값은 항상 **부모 노드**보다 큼.
- **탐색 과정**:
  1. **루트 노드**부터 시작해 찾고자 하는 값이 **루트 노드**보다 작으면 **왼쪽**으로 이동, 크면 **오른쪽**으로 이동.
  2. 이 과정을 반복하며 값을 찾음.
- **시간 복잡도**: 평균적으로 O(log N), 최악의 경우(트리가 한쪽으로 치우친 경우) O(N).

---

### 트리 자료구조와 관련된 알고리즘

#### 1. **이진 탐색 트리 (Binary Search Tree, BST)**
   - 이진 탐색(Binary Search) 알고리즘과 밀접한 관련이 있음.
   - 노드 삽입, 삭제, 탐색 모두 평균적으로 O(log N)의 시간 복잡도를 가짐.

#### 2. **힙(Heap)**
   - 우선순위 큐(Priority Queue)를 구현할 때 사용하는 트리 구조.
   - 최소 힙(min-heap) 또는 최대 힙(max-heap)을 사용하여 데이터를 정렬하고, 삽입/삭제 연산에서 O(log N)의 시간 복잡도를 가짐.

#### 3. **트라이(Trie)**
   - **문자열 탐색**을 위한 특수 트리 자료구조로, 접두사를 빠르게 탐색하는 데 유용.
   - 사전(Dictionary) 형태의 문제나 자동 완성 기능 구현에 사용됨.

#### 4. **세그먼트 트리(Segment Tree)**
   - 구간 합, 최소/최대값 등 범위 쿼리 문제에 사용되는 트리 구조.
   - O(log N)의 시간 복잡도로 구간 쿼리를 처리할 수 있음.

#### 5. **DFS/BFS 탐색**
   - **깊이 우선 탐색(DFS)**과 **너비 우선 탐색(BFS)** 모두 트리 구조에서 자주 사용됨.
   - DFS는 스택, BFS는 큐를 사용하여 트리 또는 그래프를 순회함.

---

### 트리와 관련된 주요 개념

#### AVL 트리 및 레드-블랙 트리
- **AVL 트리**와 **레드-블랙 트리**는 균형 이진 탐색 트리로, 삽입/삭제 후에도 트리의 균형을 유지함.
- 이들 트리는 트리의 높이를 O(log N)으로 유지하여 성능을 보장함.

#### 파라메트릭 서치 (Parametric Search)
- **파라메트릭 서치**는 최적화 문제를 결정 문제로 바꿔서 해결하는 기법으로, 이진 탐색을 사용하여 최적의 값을 찾는 문제에 사용됨.
- 대표적인 문제 유형: **가장 알맞은 값 찾기** 문제.

---

### 트리 탐색과 정렬의 일반적인 적용

- **트리 자료구조**는 데이터를 효율적으로 저장하고 탐색할 수 있게 도와주는 기본 구조로, 특히 **계층적**인 데이터를 다룰 때 적합.
- **이진 탐색 트리**, **힙** 등을 통해 효율적인 탐색, 삽입, 삭제가 가능하며, 다양한 알고리즘과 결합되어 **빠르고 안정적인 성능**을 제공함.

## 다이나믹 프로그래밍 (Dynamic Programming)

### 정의
- 다이나믹 프로그래밍은 한 번 계산한 문제를 다시 계산하지 않도록 하는 알고리즘.
- 큰 문제를 작은 문제로 나누고, 같은 문제를 한 번만 풀어 효율적으로 해결함.

### 적용 가능한 예시
- **피보나치 수열**: 다이나믹 프로그래밍을 적용하여 효율적으로 계산할 수 있는 대표적인 문제.

### 다이나믹 프로그래밍 적용 조건
1. **큰 문제를 작은 문제로 나눌 수 있음**: 문제를 쪼개어 부분 문제로 해결 가능.
2. **작은 문제의 정답이 그 문제를 포함하는 큰 문제에서도 동일함**: 작은 문제의 결과가 재사용 가능.

### 메모이제이션 기법 (Memoization)
- 다이나믹 프로그래밍을 구현하는 방법 중 하나.
- 한 번 구한 결과를 **메모리** 공간에 저장(메모)해두고, 같은 식을 다시 호출하면 저장된 결과를 재사용하는 기법. 
- **캐싱**이라고도 부름.

### 분할 정복과의 차이점
- **분할 정복**과 **다이나믹 프로그래밍**은 문제를 작은 단위로 쪼개는 방식은 비슷하지만, **다이나믹 프로그래밍**은 쪼개진 작은 문제들이 서로 영향을 미침.

## 최단 경로 알고리즘
**정의**
- **최단 경로**는 길찾기 문제로, 한 지점에서 다른 특정 지점까지의 가장 짧은 경로를 찾는 알고리즘.
- **문제 정형화**:
  - 한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 문제.
  - 모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 문제 등.
  
- 일반적으로 **최단 거리**를 출력하는 문제에서 자주 사용됨.

**알고리즘 적용**
- **그리디 알고리즘**과 **다이나믹 프로그래밍**이 최단 경로 알고리즘에 적용될 수 있음.


### 다익스트라 최단 경로 알고리즘

#### 정의
- **다익스트라 알고리즘**은 여러 개의 노드가 있는 **그래프**에서 **특정 노드에서 출발**하여 다른 노드로 가는 **최단 경로**를 구하는 알고리즘.
- **음의 간선**이 없는 그래프에서만 정상적으로 동작함.
- **그리디 알고리즘**으로 분류되며, 매번 가장 비용이 적은 노드를 선택해 처리함.

#### 원리
1. **출발 노드** 설정.
2. **최단 거리 테이블** 초기화.
3. 방문하지 않은 노드 중에서 **최단 거리가 가장 짧은 노드**를 선택.
4. 선택한 노드를 거쳐 다른 노드로 가는 비용을 계산하여 **최단 거리 테이블** 갱신.
5. 3, 4 과정을 반복.

### 구현 방법
- **ver1**: 구현은 쉽지만 느림.
- **ver2**: 구현은 복잡하지만 빠름 (우선순위 큐 사용).

## 기타 그래프 이론

